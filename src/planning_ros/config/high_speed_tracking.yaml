# I/O Topics
input_cones_topic:              "localization/cone_map"                 #用于接收锥筒
input_pose_topic:               "localization/car_state"                #用于接受车身位姿消息
output_pathlimits_topic:        "planning/pathlimits"          #主链路统一路径输出话题（Planning -> Control 单一真值）
stop_topic:                     "planning/high_speed_tracking/stop"     #发布车辆停止信号

# Visualization data
publish_viz_data:              false   # bool   [-]   兼容侧通道：内部可视化数据发布（默认关闭，主链路已解耦）
viz_topic:                     "planning/high_speed_tracking/viz"                   # visualization data output

## Params

# stop
number_of_stopped_turns:        1       # int    [-]   赛车停止的圈数（需要完成的圈数）
wait_full_before_stop:          true    # bool   [-]   触发完成圈数后，若尚未发布 full 路径则先延迟停车
finish_grace_frames:            300     # int    [frame] 延迟停车最大帧数（等待 partial->full 切换）
enable_loop_fallback_by_lap_counter: true # bool [-]   几何回环未触发时，按圈计数触发 full 发布兜底
loop_fallback_min_laps:         2       # int    [lap]  延后兜底触发，优先让原始几何回环先接管 full 切换
debug_save_way_files:           false   # bool   [-]   调试开关：是否把路径写入testData与loops文件（默认关闭）

# path
    # 通过不同的x传出不同的类型路径,供不同种类的控制模块使用,插值都是线性的,默认为0模式
    # 0：获取全部的全局坐标系下的路径
    # 1：对车到下一目标点中间进行插值
    # 2：局部路径插值
    # 3：全路径插值
    # 4：局部路径插值(局部坐标)
    # 5：全路径插值(局部坐标)
    # 6：局部坐标系下的路径
    # 注：4/5 当前会兼容回退到 2/3（本仓库未实现独立的局部坐标插值函数）
the_mode_of_partial_path:       2       # int    [-]   选择发布路径的方式(未回环)
the_mode_of_full_path:          3       # int    [-]   选择发布路径的方式(已回环)

# Filtering
min_cone_confidence:            0.0     # float  [-]   置信度阈值：低于此值的锥桶不会参与规划
max_triangle_edge_len:          7.0     # double [m]   过滤掉有边长大于此值的三角形
min_triangle_angle:             0.20    # double [-]   内角小于此值的三角形被删除(弧度制)
max_dist_circum_midPoint:       10.0    # double [m]   中点与三角形外接圆心之间的最大距离限制,超过此限制会被删除

# Search
max_way_horizon_size:           0       # int    [num] 车前方路径点的最大值,0等于无穷,也就是有多少就找多少路径点
max_search_tree_height:         7       # int    [num] 树搜索的最大值, 越大越好
search_radius:                  15.0    # double [m]   搜索路径的半径,多了会增大耗时,少了不好出路径
max_angle_diff:                 1.4     # double [rad] 中点构成的路径之间最大的角度差范围是( 0, pi/2)
edge_len_diff_factor:           1.2     # double [-]   如果路径的平均边长为x，则只有当x-this*x < length(e) <= x+x*this时，才会考虑属于边e的中点
max_search_options:             3       # int    [num] 搜索过程中树中每个节点的最大子节点数，2是稳定的，3是危险的
max_next_heuristic:             4.0     # double [-]   启发值门槛,需要根据锥筒间距来进行调整,如果太小会规划不出来路径,太大则会让路径不可靠
heur_dist_ponderation:          0.4     # float  [-]   范围( 0.0,  1.0)计算启发值的时候给长度的权重
allow_intersection:             false   # bool   [-]   是否允许路径交叉(路径中的循环)
max_treeSearch_time:            0.10    # float  [s]   树搜索所能花费的最大时间，否则，搜索将停止，并选择最好的中点(并添加到路径中)

# Loop Closure                  #这个应该不用怎么碰,关于圈数和关闭节点是用的另外的判定方式
shutdown_on_loop_closure:       false   # bool   [-]   路线闭环之后是否关闭节点
max_dist_loop_closure:          2.3     # double [m]   回环判定首尾距离阈值（基于 rosbag 标定，兼顾鲁棒与误触发）
max_angle_diff_loop_closure:    0.65    # double [rad] 用于确定闭环中首尾中间点之间的最大角度差

# Speed Profile (P1)
speed_cap_safe:                 11.11   # double [m/s] SAFE_LAP 速度上限（约 40 km/h）
speed_cap_fast:                 13.33   # double [m/s] FAST_LAP 速度上限（约 48 km/h）
max_lateral_acc:                6.5     # double [m/s^2] 曲率限速使用的横向加速度上限
max_accel:                      2.5     # double [m/s^2] 前向积分加速度上限
max_brake:                      4.0     # double [m/s^2] 后向积分制动上限（正值）
min_speed:                      1.0     # double [m/s] 最低巡航速度，避免低速抖动
curvature_epsilon:              0.001   # double [1/m] 曲率限速分母下限
mode_transition_frames:         40      # int    [frame] SAFE_LAP/FAST_LAP 速度上限渐进过渡帧数
curvature_limit:                0.222   # double [1/m] AUT 几何曲率参考上限（R>=4.5m）
curvature_warn_limit_scale:     1.08    # double [-]   告警/质量判定容差倍率（仅用于告警统计，不改变速度约束的曲率值）
curvature_smoothing_enable:     true    # bool   [-]   对输出路径做轻量曲率平滑
curvature_smoothing_max_iters:  4       # int    [iter] 曲率平滑最大迭代次数
curvature_smoothing_alpha:      0.25    # double [-]   每次将超限点拉向邻点中点的比例
curvature_warn_ratio:           0.12    # double [-]   超限点比例达到该阈值才告警
curvature_warn_min_points:      8       # int    [num] 超限点最小数量门槛
min_publish_path_size:          12      # int    [num] 可发布路径最小点数，低于该值视为短路径
short_path_stable_relax_points: 3       # int    [num] 已有稳定路径时，短路径阈值放宽点数（减少持有回退触发）
hold_last_valid_path:           true    # bool   [-]   短路径时保留上次有效路径
hold_last_valid_max_frames:     25      # int    [frame] 最多连续保留帧数
loop_close_debounce_frames:     1       # int    [frame] 回环成立防抖帧数，几何回环一旦成立立即切到 FAST_LAP
loop_open_debounce_frames:      15      # int    [frame] 回环失效防抖帧数，连续失效后回退到 SAFE_LAP
loop_allow_reopen:              false   # bool   [-]   默认锁存 FAST_LAP，不因短时回环抖动回退 SAFE（降低 full 发布抖动）
mode_min_hold_frames:           30      # int    [frame] 模式切换后的最短驻留帧数，避免来回抖动
search_adaptive_enable:         true    # bool   [-]   启用短路径自适应搜索（放宽 search_radius / max_next_heuristic）
search_adaptive_trigger_frames: 1       # int    [frame] 连续短路径达到该帧数后开始放宽搜索参数
search_adaptive_step_frames:    1       # int    [frame] 每累计该帧数，放宽等级 +1
search_adaptive_max_level:      8       # int    [-]   放宽等级上限
search_adaptive_bootstrap_level: 4      # int    [-]   在尚无稳定路径时使用的基础放宽等级
search_adaptive_radius_step:    3.0     # double [m]   每级额外增加的搜索半径
search_adaptive_heuristic_step: 1.0     # double [-]   每级额外增加的启发值阈值
search_adaptive_radius_max:     40.0    # double [m]   搜索半径放宽上限
search_adaptive_heuristic_max:  14.0    # double [-]   启发值阈值放宽上限
search_adaptive_retry_on_short: true    # bool   [-]   当帧短路径时立即用更宽参数重算一次
loop_diag_enable:               false   # bool   [-]   打印几何回环诊断（way_size/首尾距/尾点到历史最小距）

# Replan flag
vital_num_midpoints:            10      # int    [num] 没搞清楚,建议没问题就别动.number of midpoints that are considered "vital" from the car's position on. This is taken into account when computing the (inner) replan flag.

# Fail safe(s)                  #没搞明白,没问题建议别动
failsafe_max_way_horizon_size:  6       # int    [num] 在故障安全触发的时候，车前方的大小将设置为此值。避免不良影响
general_failsafe:               true    # bool   [-]   当没有可能找到一条不使用颜色的路径（路径长度小于一个常数）时，通用故障保护机制会自动将所有搜索参数增加一个因子。一旦使用正常参数计算出的路径长度足够长，它将切换回正常的功能。简单来说，这个设置项控制是否允许在无法找到足够长的不使用颜色的路径时，自动增加搜索参数来进行故障保护
general_failsafe_safetyFactor:  1.8     # double [-]   当启动通用故障保护时，搜索参数将增加一个系数,干嘛的我也不知道



perf_stats_enable: true   # bool   [-]     是否启用性能统计功能，启用后会记录每次规划的时间和路径长度等信息，方便调试和优化
perf_stats_window: 300     # int    [num]   性能统计的窗口大小，表示在计算平均性能指标时考虑的最近规划次数
perf_stats_log_every: 50   # int    [num]   每隔多少次规划记录一次性能统计信息到日志中，0表示不记录
